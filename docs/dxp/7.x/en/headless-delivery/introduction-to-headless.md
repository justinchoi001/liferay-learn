# Using Liferay DXP as a Headless Platform

Liferay DXP provides a rich interface out-of-the-box to interact with its features. Oftentimes this interface provides everything necessary for your use-cases, and there's no need for anything else.

But there's another option for interacting with Liferay DXP, which, while taking more effort than the out-of-the-box interface, gives you even more power for getting things done: Liferay DXP's headless functionality. This option becomes indispensible when there's a need to get data in a machine-readable format, for example in writing mobile applications, custom web applications, or automated processes. By exposing web APIs, Liferay DXP allows custom applications to perform the same actions as can be done by a user using the web interface.

WRITE A LITTLE BIT ABOUT CREATING A CLIENT HERE (or maybe below?)

OVERALL INTRODUCE MORE SCOPE TO PREPARE READER FOR MORE OF THE SUBJECT CONTENT IN FOLLOWING SECTION

## Ways to Connect

There are three different approaches available for clients to connect to Liferay DXP via web API:
* __Headless REST APIs__, conforming to the [OpenAPI specification](https://swagger.io/docs/specification/about/)
* The __GraphQL API__ conforming to the [GraphQL specification](https://graphql.github.io/graphql-spec/June2018/)
* __Plain Web/REST Services__, generated by Service Builder

### Headless REST APIs

Liferay DXP's headless APIs allow [RESTful](https://www.w3.org/TR/2004/NOTE-ws-arch-20040211/#relwwwrest) interaction with Liferay DXP resources. These APIs follow the [OpenAPI specification](https://swagger.io/docs/specification/about/), which defines a standard for REST interfaces, allowing for more straightforward implementation and consumption.

Detailed information on these APIs can be found by accessing the definitions on a running Liferay DXP instance at `[server][:port]/o/api` or exploring their documentation on [SwaggerHub](https://app.swaggerhub.com/apis/liferayinc/).

### GraphQL API

The GraphQL API is accessed using [GraphQL](https://graphql.org/), a query language that supports interactions similar to the headless REST APIs, but with slightly more flexibility.

Detailed information on this API can be found by exploring the API itself or its documentation through a GraphQL client. Liferay DXP includes a built-in client that can be found on a running Liferay DXP instance at `[server][:port]/o/api` (select "GraphQL" on the top-right). [External clients](https://graphql.org/graphql-js/graphql-clients/) can also be used, targeting `[server][:port]/o/graphql`.

### Plain Web/REST Services

Liferay DXP's Web Services are part of an older framework, still supported by DXP but no longer recommended for complex headless operations. These APIs are closely tied to Liferay DXP's internal workings and thus lack the power and flexibility that the newer headless options provide.

However, Web Services may provide a simpler way to execute certain tasks. See [Service Builder Web Services](https://help.liferay.com/hc/en-us/articles/360017887112-Service-Builder-Web-Services) for how to use them.

## Features

### Work with Any Client

The data is served up over web API, so any application capable of making web calls can serve as a client. And work with the data in the format you're most comfortable with, too. Liferay DXP's APIs respond with JSON content by default, also support XML natively, and allow extensions to serve content in any other way you might need. See REFERENCE ARTICLE for how to do this.

### Connect Securely

Liferay DXP's APIs support three ways of authentication: basic authentication, via OAuth token, and via Cookie. See REFERENCE ARTICLE for how to do this. It's also possible to make API requests as a guest â€“ see UNAUTHENTICATED REQUESTS for more details.

### Handle Large Amounts of Data

Working with large sets of data can quickly become overwhelming for a client to handle. Performance issues or bandwidth usage caused by this can be very expensive and/or frustrating for users. So Liferay DXP's headless APIs provide a way to break down collections into manageable chunks. By passing `page` and `pageSize` parameters in a request, you can tell the API how much information you want at a time, and which subset of information you want in a given request. The `sort` parameter is also effective in combination with paged responses, allowing you to indicate which elements should be returned first. See REFERENCE ARTICLE on specifics for how to make this happen.

### Keep It Concise

Another way to keep response sizes small and processing streamlined is to specify which information is relevant by other criteria.

The `search` parameter executes a keyword search, yielding elements that contain that keyword in any part of their entries. The `filter` parameter executes a similar search, but with the exact part of the entry where the content must be contained specified.

The `fields` parameter requests only specific fields to be enumerated in each of the elements in the response.

The `flatten` parameter executes your request out of a hierarchical context, for hierarchical APIs. This allows you to, for instance, search for any Organization called "Marketing" rather than having to traverse the org-chart to find the relevant Organization.
